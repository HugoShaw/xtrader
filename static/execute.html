<!-- app/static/execute.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>xtrader - Execute UI</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0f19; color: #e8eefc; }
    header { padding: 18px 20px; border-bottom: 1px solid rgba(255,255,255,.08); }
    header h1 { margin: 0; font-size: 18px; font-weight: 650; }
    header p { margin: 6px 0 0; opacity: .8; font-size: 13px; }

    .wrap { max-width: 1200px; margin: 0 auto; padding: 18px 20px 40px; display: grid; gap: 14px; }
    .grid { display: grid; grid-template-columns: 380px 1fr; gap: 14px; align-items: start; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; overflow: hidden; }
    .card h2 { margin: 0; padding: 14px 14px 10px; font-size: 14px; font-weight: 650; border-bottom: 1px solid rgba(255,255,255,.08); }
    .card .content { padding: 14px; display: grid; gap: 12px; }

    label { display: grid; gap: 6px; font-size: 12px; opacity: .9; }
    input, select, textarea {
      width: 100%;
      box-sizing: border-box;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: #e8eefc;
      padding: 10px 10px;
      outline: none;
    }
    input:focus, textarea:focus, select:focus { border-color: rgba(110,168,254,.6); }

    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 520px) { .row { grid-template-columns: 1fr; } }

    .btns { display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: #e8eefc;
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 650;
    }
    button.primary { background: rgba(110,168,254,.25); border-color: rgba(110,168,254,.45); }
    button.ghost { background: rgba(255,255,255,.05); border-color: rgba(255,255,255,.12); }
    button.danger { background: rgba(255, 107, 107, .18); border-color: rgba(255, 107, 107, .45); }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .status {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      font-size: 12px;
      display: grid;
      gap: 6px;
    }

    .muted { opacity: .75; font-size: 12px; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,.14); font-size: 11px; opacity: .95; }
    .pill.ok { border-color: rgba(64, 192, 128, .55); }
    .pill.bad { border-color: rgba(255, 107, 107, .55); }
    .pill.info { border-color: rgba(110,168,254,.55); }

    /* Pretty response renderer */
    .respWrap { padding: 14px; display: grid; gap: 12px; }
    .respTop { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .respTitle { display: flex; align-items: center; gap: 10px; }
    .respTitle strong { font-size: 14px; }
    .kvs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 900px) { .kvs { grid-template-columns: 1fr; } }

    .kv {
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 6px;
    }
    .kv .k { font-size: 11px; opacity: .75; }
    .kv .v { font-size: 13px; font-weight: 650; }
    .kv .s { font-size: 12px; opacity: .85; line-height: 1.35; white-space: pre-wrap; }

    details {
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      background: rgba(0,0,0,.25);
      overflow: hidden;
    }
    details summary {
      cursor: pointer;
      padding: 10px 12px;
      font-weight: 650;
      font-size: 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      list-style: none;
    }
    details summary::-webkit-details-marker { display: none; }

    pre {
      margin: 0;
      padding: 12px;
      background: rgba(0,0,0,.15);
      overflow: auto;
      max-height: 520px;
      font-size: 12px;
      line-height: 1.35;
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
    }

    .historyList { padding: 10px 14px 14px; display: grid; gap: 10px; }
    .histItem {
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 6px;
    }
    .histTop { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap: wrap; }
    .histMeta { font-size: 12px; opacity: .9; }
    .histMeta code { opacity: .9; }
    .histSmall { font-size: 12px; opacity: .8; white-space: pre-wrap; }
    .copyBtn {
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 10px;
    }

    /* --- Candlestick plot --- */
    .chartCard {
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 8px;
    }
    .chartCard.snapshot {
      border: 1px solid rgba(110,168,254,.28);
      background:
        radial-gradient(1200px 300px at 10% -20%, rgba(110,168,254,.18), transparent 55%),
        linear-gradient(180deg, rgba(9,12,20,.9), rgba(6,9,16,.95));
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
    }
    .chartTop {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      cursor: pointer;
      user-select: none;
      border-radius: 10px;
      padding: 6px 6px;
    }
    .chartTop:hover { background: rgba(255,255,255,.04); }
    .chartCard.snapshot .chartTop {
      padding: 10px 10px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
    }

    .chartTop .title {
      font-size: 12px;
      font-weight: 650;
      opacity: .95;
      display:flex;
      gap: 8px;
      align-items: center;
    }
    .chartCard.snapshot .chartTop .title {
      font-size: 13px;
      letter-spacing: .2px;
    }
    .chartCard.snapshot .chartTop .title .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(110,168,254,.45);
      background: rgba(110,168,254,.18);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .6px;
    }
    .chartTop .title .chev {
      display:inline-block;
      width: 16px;
      text-align: center;
      opacity: .85;
      transform-origin: 50% 55%;
      transition: transform .15s ease;
    }
    .chartCard.folded .chartTop .title .chev { transform: rotate(-90deg); }

    .chartTop .meta { font-size: 11px; opacity: .75; }
    /* --- Candlestick plot --- */
    .chartWrap { 
      position: relative; 
      width: 100%; 
      height: min(520px, 48vh);     /* taller, responsive */
      min-height: 340px;           /* avoids tiny chart */
    }

    @media (max-width: 980px) {
      .chartWrap { height: min(520px, 42vh); min-height: 300px; }
    }

    /* For history charts you may want a slightly smaller height */
    #chartsList .chartWrap {
      height: min(420px, 38vh);
      min-height: 260px;
    }
    canvas.candle {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 10px;
      background: rgba(0,0,0,.10);
    }
    .chartHint { font-size: 11px; opacity: .75; line-height: 1.35; }

    /* --- Zoom UI --- */
    .chartTools {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .toolBtn {
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: #e8eefc;
      cursor: pointer;
      font-weight: 650;
      opacity: .9;
    }
    .toolBtn:hover { background: rgba(255,255,255,.10); }
    .toolBtn.active {
      background: rgba(110,168,254,.25);
      border-color: rgba(110,168,254,.45);
      opacity: 1;
    }
    .chartCard.snapshot .toolBtn {
      padding: 7px 12px;
      border-color: rgba(110,168,254,.4);
      background: rgba(110,168,254,.16);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.05);
    }
    .chartCard.snapshot .toolBtn:hover { background: rgba(110,168,254,.22); }

    .zoomBox {
      position: absolute;
      display: none;
      pointer-events: none;
      border: 1px dashed rgba(110,168,254,.95);
      background: rgba(110,168,254,.15);
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .chartHint .hintZoom {
      margin-left: 8px;
      opacity: .85;
    }

    .markerTip {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -110%);
      background: rgba(0,0,0,.80);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.25;
      color: #e8eefc;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display: none;
      white-space: nowrap;
    }
    .markerTip .a { font-weight: 750; }
    .markerTip .sub { opacity: .85; font-size: 11px; margin-top: 2px; }
    .markerTip .dot {
      display:inline-block;
      width: 8px; height: 8px;
      border-radius: 999px;
      margin-right: 6px;
      vertical-align: middle;
      border: 1px solid rgba(255,255,255,.18);
    }
    .markerTip .dot.buy { background: rgba(110,168,254,.95); }
    .markerTip .dot.sell { background: rgba(255,107,107,.95); }

    .candleTip {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -115%);
      background: rgba(12, 16, 26, .92);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.25;
      color: #e8eefc;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display: none;
      white-space: nowrap;
    }
    .candleTip .t { font-weight: 700; }
    .candleTip .sub { opacity: .85; font-size: 11px; margin-top: 2px; }

    .chartCard.folded .chartWrap,
    .chartCard.folded .chartHint { display: none; }

    .modeRow { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .seg {
      display: inline-flex;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      overflow: hidden;
      background: rgba(0,0,0,.20);
    }
    .seg button {
      border: none;
      border-right: 1px solid rgba(255,255,255,.12);
      border-radius: 0;
      padding: 8px 10px;
      font-size: 12px;
      background: transparent;
      opacity: .85;
    }
    .seg button:last-child { border-right: none; }
    .seg button.active { background: rgba(110,168,254,.25); opacity: 1; }

    .summaryWrap { padding: 12px 14px 6px; display: grid; gap: 10px; }
    .summaryGrid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
    @media (max-width: 980px) { .summaryGrid { grid-template-columns: 1fr 1fr; } }
    @media (max-width: 520px) { .summaryGrid { grid-template-columns: 1fr; } }

    .hintBox {
      border: 1px dashed rgba(255,255,255,.14);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(0,0,0,.18);
      font-size: 12px;
      line-height: 1.4;
      opacity: .9;
    }
  </style>
</head>

<body>
<header>
  <h1>xtrader trading UI</h1>
  <p>
    Send a symbol + trading context to
    <span class="pill info">POST /signal/{symbol}</span>
    or
    <span class="pill info">POST /execute/{symbol}</span>.
    Timestamps shown in <span class="pill info">Asia/Shanghai</span>.
  </p>
</header>

<div class="wrap">
  <div class="grid">
    <!-- Left: Inputs -->
    <div class="card">
      <h2>Request Settings</h2>
      <div class="content">
        <label>
          Stock Symbol (6 digits)
          <input id="symbol" placeholder="e.g. 600519" />
        </label>

        <div class="modeRow">
          <div class="seg" role="tablist" aria-label="Mode">
            <button id="modeExecute" class="active" type="button">Execute</button>
            <button id="modeSignal" type="button">Signal</button>
          </div>
          <div class="muted">Mode determines which route is called.</div>
        </div>

        <div class="row">
          <label>
            Cash (CNY)
            <input id="cash" type="number" step="0.01" placeholder="e.g. 100000" />
          </label>
          <label>
            Position Shares
            <input id="pos" type="number" step="1" placeholder="e.g. 0" />
          </label>
        </div>

        <div class="row">
          <label>
            Avg Cost (CNY)
            <input id="avgCost" type="number" step="0.01" placeholder="e.g. 12.34" />
          </label>
          <label>
            Unrealized PnL (CNY)
            <input id="upl" type="number" step="0.01" placeholder="e.g. 0" />
          </label>
        </div>

        <div class="row">
          <label>
            now_ts (optional)
            <input id="nowTs" placeholder='Optional: "YYYY-MM-DD HH:MM:SS" (Asia/Shanghai). Leave blank to let backend use server Shanghai time.' />
          </label>
          <label>
            Frequency (seconds)
            <input id="freqSec" type="number" step="1" min="1" placeholder="e.g. 30" />
          </label>
        </div>

        <h2 style="margin:0; padding: 6px 0 0; border: none;">Options Overrides (optional)</h2>

        <div class="row">
          <label>
            timezone_name
            <input id="tzName" placeholder="Asia/Shanghai" />
          </label>

          <label>
            strategy_mode
            <select id="strategyMode">
              <option value="mild">mild</option>
              <option value="normal">normal</option>
              <option value="aggressive">aggressive</option>
            </select>
          </label>
        </div>

        <div class="row">
          <label>
            lot_size
            <input id="lotSize" type="number" step="1" min="1" placeholder="100" />
          </label>
          <label>
            max_order_shares (0 = no cap)
            <input id="maxOrderShares" type="number" step="1" min="0" placeholder="10000" />
          </label>
        </div>

        <div class="row">
          <label>
            fees_bps_est
            <input id="feesBps" type="number" step="1" min="0" placeholder="5" />
          </label>
          <label>
            slippage_bps_est
            <input id="slipBps" type="number" step="1" min="0" placeholder="5" />
          </label>
        </div>

        <h2 style="margin:0; padding: 6px 0 0; border: none;">Market Options (matches backend MarketOptionsIn)</h2>

        <div class="row">
          <label>
            market.min_period
            <input id="marketMinPeriod" placeholder='e.g. "1"' />
          </label>
          <label>
            market.min_lookback_minutes
            <input id="marketMinLookback" type="number" step="1" min="1" placeholder="120" />
          </label>
        </div>

        <div class="row">
          <label>
            market.include_bars
            <select id="marketIncludeBars">
              <option value="true">true</option>
              <option value="false">false</option>
            </select>
          </label>
          <label>
            market.include_orderbook
            <select id="marketIncludeOrderbook">
              <option value="false">false</option>
              <option value="true">true</option>
            </select>
          </label>
        </div>

        <label>
          market.extra (JSON object, optional; merged last and can override above)
          <textarea id="marketExtra" rows="4" placeholder='{"foo": 1, "bar": "x"}'></textarea>
        </label>

        <div class="hintBox">
          Backend mapping reminder:
          <div class="muted" style="margin-top:6px;">
            <code>ctx.options.market.to_kwargs()</code> sends:
            <code>min_period</code>,
            <code>min_lookback_minutes</code>,
            <code>include_orderbook</code>,
            <code>include_bars</code>,
            plus <code>extra</code> merged last.
          </div>
        </div>

        <div class="btns">
          <button id="btnOnce" class="primary">Call Once</button>
          <button id="btnStart" class="primary">Start Auto</button>
          <button id="btnStop" class="danger" disabled>Stop Auto</button>
          <button id="btnClear" class="ghost" title="Clear output only">Clear Output</button>
        </div>

        <div class="status" id="statusBox">
          <div>Status: <span id="runState" class="pill">idle</span></div>
          <div>Last call (Shanghai): <span id="lastCall" class="muted">—</span></div>
          <div>Last result: <span id="lastResult" class="muted">—</span></div>
          <div class="muted">Tip: inputs are saved locally in your browser.</div>
        </div>

        <div class="muted">
          This page posts <code>TradingContextIn</code> payload to
          <code id="routeLabel">/execute/{symbol}</code>
          (or <code>/signal/{symbol}</code> in Signal mode).
        </div>

        <div class="muted">
          Summary rules:
          <ul style="margin:6px 0 0 18px; padding:0; line-height: 1.45;">
            <li>Counts only <b>accepted paper</b> trades: <code>route=execute</code>, <code>ok=true</code>, <code>paper=true</code>, <code>action=BUY/SELL</code>, and <code>lots&gt;0</code>.</li>
            <li>PnL is computed in frontend using FIFO matching. If no fill price is provided, it falls back to snapshot last price (less accurate).</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Right: Output -->
    <div class="card">
      <h2>Response</h2>
      <div id="resp" class="respWrap">
        <div class="muted">(no response yet)</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>History (latest 30) + Intraday Paper Summary</h2>

    <div class="summaryWrap">
      <div id="summaryNote" class="muted">Summary updates after each successful /execute call (paper accepted).</div>
      <div id="summaryBar" class="summaryGrid">
        <div class="kv">
          <div class="k">Accepted paper trades</div>
          <div class="v">—</div>
          <div class="s muted">execute ok=true paper=true</div>
        </div>
        <div class="kv">
          <div class="k">Net lots / shares</div>
          <div class="v">—</div>
          <div class="s muted">BUY lots - SELL lots</div>
        </div>
        <div class="kv">
          <div class="k">Realized PnL (CNY)</div>
          <div class="v">—</div>
          <div class="s muted">FIFO matched</div>
        </div>
        <div class="kv">
          <div class="k">Unrealized PnL (CNY)</div>
          <div class="v">—</div>
          <div class="s muted">Open lots vs last price</div>
        </div>
      </div>
    </div>

    <div class="historyList" id="chartsList"></div>
    <div id="history" class="historyList">(empty)</div>

  </div>
</div>

<script>
  // -----------------------------
  // Helpers
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const TZ = "Asia/Shanghai";

  function shanghaiNowYmdHms() {
    const dt = new Date();
    const parts = new Intl.DateTimeFormat("sv-SE", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).formatToParts(dt);

    const get = (type) => parts.find(p => p.type === type)?.value ?? "";
    return `${get("year")}-${get("month")}-${get("day")} ${get("hour")}:${get("minute")}:${get("second")}`;
  }

   function shanghaiTodayYmd() {
    const dt = new Date();
    const parts = new Intl.DateTimeFormat("sv-SE", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
    }).formatToParts(dt);

    const get = (type) => parts.find(p => p.type === type)?.value ?? "";
    return `${get("year")}-${get("month")}-${get("day")}`;
  }

  // Returns { start: "YYYY-MM-DD 00:00:00", end: "YYYY-MM-DD 23:59:59" } in Shanghai date
  function shanghaiTodayRangeHms() {
    const ymd = shanghaiTodayYmd();
    return {
      start: `${ymd} 00:00:00`,
      end: `${ymd} 23:59:59`,
    };
  }

  // Returns { start, end } for last N days including today, Shanghai date.
  // Example n=3 => start = (today-2) 00:00:00, end = today 23:59:59
  function shanghaiRecentDaysRangeHms(nDays = 3) {
    const n = Math.max(1, Math.floor(Number(nDays) || 1));
    const today = shanghaiTodayYmd(); // "YYYY-MM-DD" in Shanghai

    // Parse today as Shanghai midnight => epoch ms (UTC-8 conversion)
    const m = today.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return shanghaiTodayRangeHms();

    const yyyy = Number(m[1]), MM = Number(m[2]), dd = Number(m[3]);
    const todayMidnightMs = Date.UTC(yyyy, MM - 1, dd, 0 - 8, 0, 0); // 00:00:00 Shanghai

    const startMs = todayMidnightMs - (n - 1) * 24 * 60 * 60 * 1000; // back (n-1) days

    const startYmd = toShTsYmdHmsFromMs(startMs).slice(0, 10); // "YYYY-MM-DD"
    return {
      start: `${startYmd} 00:00:00`,
      end: `${today} 23:59:59`,
    };
  }

  function normalizeNowTs(input) {
    const s = String(input || "").trim();
    if (!s) return "";
    if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(s)) return s;

    const d = new Date(s);
    if (!isNaN(d.getTime())) {
      const parts = new Intl.DateTimeFormat("sv-SE", {
        timeZone: TZ,
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      }).formatToParts(d);

      const get = (type) => parts.find(p => p.type === type)?.value ?? "";
      return `${get("year")}-${get("month")}-${get("day")} ${get("hour")}:${get("minute")}:${get("second")}`;
    }
    return s;
  }

  function safeNumber(v, fallback=null) {
    if (v === undefined || v === null) return fallback;
    const s = String(v).trim();
    if (s === "") return fallback;
    const n = Number(s);
    return Number.isFinite(n) ? n : fallback;
  }

  function safeBoolFromSelect(v, fallback=null) {
    const s = String(v ?? "").trim().toLowerCase();
    if (s === "true") return true;
    if (s === "false") return false;
    return fallback;
  }

  function normalizeSymbol(sym) {
    const s = String(sym || "").trim();
    return s.split(".", 1)[0];
  }

  function setRunState(text, kind=null) {
    const el = $("runState");
    el.textContent = text;
    el.className = "pill";
    if (kind === "ok") el.classList.add("ok");
    if (kind === "bad") el.classList.add("bad");
    if (!kind) el.classList.add("info");
  }

  function setStatus(lastCall, lastResult) {
    $("lastCall").textContent = lastCall || "—";
    $("lastResult").textContent = lastResult || "—";
  }

  function pretty(obj) { return JSON.stringify(obj, null, 2); }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function pick(obj, keys) {
    for (const k of keys) {
      if (obj && Object.prototype.hasOwnProperty.call(obj, k) && obj[k] !== undefined && obj[k] !== null) {
        return obj[k];
      }
    }
    return undefined;
  }

  function normalizeAction(a) {
    const s = String(a || "").toUpperCase();
    if (["BUY","SELL","HOLD"].includes(s)) return s;
    return s || "—";
  }

  function actionPill(action) {
    const a = normalizeAction(action);
    let cls = "pill info";
    if (a === "BUY") cls = "pill ok";
    if (a === "SELL") cls = "pill bad";
    return `<span class="${cls}">${escapeHtml(a)}</span>`;
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try {
        document.execCommand("copy");
        document.body.removeChild(ta);
        return true;
      } catch {
        document.body.removeChild(ta);
        return false;
      }
    }
  }

  function extractLotsFromResponse(data) {
    const v =
      pick(data, ["lots"]) ??
      pick(data, ["executed_lots"]) ??
      pick(data, ["requested_lots"]) ??
      pick(data, ["suggested_lots"]) ??
      pick(data?.details?.signal, ["suggested_lots"]) ??
      null;

    const n = (v === null || v === undefined) ? null : Number(v);
    return Number.isFinite(n) ? Math.floor(n) : null;
  }

  function extractSharesFromResponse(data) {
    const v =
      pick(data, ["shares"]) ??
      pick(data, ["executed_shares"]) ??
      pick(data, ["requested_shares"]) ??
      null;
    const n = (v === null || v === undefined) ? null : Number(v);
    return Number.isFinite(n) ? Math.floor(n) : null;
  }

  function extractCallPriceFromResponse(root) {
    const v =
      pick(root, ["fill_price", "filled_price", "exec_price", "execution_price", "price"]) ??
      pick(root?.details, ["fill_price", "filled_price", "exec_price", "execution_price", "price"]) ??
      pick(root?.details?.execution, ["fill_price", "filled_price", "exec_price", "price"]) ??
      pick(root?.details?.order, ["fill_price", "filled_price", "exec_price", "price"]) ??
      pick(root?.details?.snapshot, ["last_price"]) ??
      pick(root?.details?.snapshot, ["last"]) ??
      null;

    const n = (v === null || v === undefined) ? null : Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function formatCny(x) {
    if (x === null || x === undefined || !Number.isFinite(Number(x))) return "—";
    const n = Number(x);
    const sign = n > 0 ? "+" : "";
    return sign + n.toFixed(2);
  }

  function toShTsYmdHmsFromMs(ms) {
  const dt = new Date(ms);
  const parts = new Intl.DateTimeFormat("sv-SE", {
    timeZone: TZ,
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit", second: "2-digit",
    hour12: false
  }).formatToParts(dt);
  const get = (type) => parts.find(p => p.type === type)?.value ?? "";
  return `${get("year")}-${get("month")}-${get("day")} ${get("hour")}:${get("minute")}:${get("second")}`;
}

function addMinutesToShanghaiTs(ts, minutes) {
  // ts: "YYYY-MM-DD HH:MM:SS" (Shanghai)
  const m = String(ts).trim().match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
  if (!m) return ts;
  const yyyy = Number(m[1]), MM = Number(m[2]), dd = Number(m[3]);
  const hh = Number(m[4]), mi = Number(m[5]), ss = Number(m[6]);
  const baseMs = Date.UTC(yyyy, MM - 1, dd, hh - 8, mi, ss); // Shanghai=UTC+8
  const ms2 = baseMs + minutes * 60_000;
  return toShTsYmdHmsFromMs(ms2);
}

async function fetchBarsFromApi(symbol, start, end, freq = "1", limit = null) {
  let url =
    `/api/stock/bars?symbol=${encodeURIComponent(symbol)}` +
    `&start=${encodeURIComponent(start)}` +
    `&end=${encodeURIComponent(end)}` +
    `&freq=${encodeURIComponent(freq)}`;

  // IMPORTANT: omit limit entirely when null/undefined/"" to get ALL rows
  if (limit !== null && limit !== undefined && String(limit).trim() !== "") {
    url += `&limit=${encodeURIComponent(String(limit))}`;
  }

  const resp = await fetch(url, { method: "GET" });
  const rawText = await resp.text();
  let data;
  try { data = JSON.parse(rawText); } catch { data = { raw: rawText }; }

  if (!resp.ok) throw new Error(`bars API failed: HTTP ${resp.status} ${resp.statusText} :: ${rawText}`);
  return data;
}


// bars payload -> ohlc array {t,o,h,l,c,v}
function extractBarsFromBarsApiPayload(payload) {
  const bars = payload?.bars || [];
  const out = [];
  for (const b of bars) {
    const tms = parseBarTsMs(b?.ts);
    const o = Number(b?.open), h = Number(b?.high), l = Number(b?.low), c = Number(b?.close);
    if (!Number.isFinite(o) || !Number.isFinite(h) || !Number.isFinite(l) || !Number.isFinite(c) || tms === null) continue;
    out.push({ t: tms, o, h, l, c, v: Number(b?.volume) });
  }
  out.sort((a,b) => a.t - b.t);
  return out;
}

  // HiDPI canvas helper: size in CSS pixels, backing store in device pixels.
  // Returns a 2D context that draws in CSS pixel coordinates.
  function ensureCanvasHiDpi(canvas, cssW, cssH) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // Set CSS size
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";

    // Set backing store size
    const needW = Math.floor(cssW * dpr);
    const needH = Math.floor(cssH * dpr);

    if (canvas.width !== needW || canvas.height !== needH) {
      canvas.width = needW;
      canvas.height = needH;
    }

    const ctx = canvas.getContext("2d");
    // Draw in CSS pixel coordinates
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = true;
    return ctx;
  }

  // Optional: call this before drawing if your wrapper size may change
  function getCanvasCssSize(canvas, fallbackW = 900, fallbackH = 260) {
    const wrap = canvas.parentElement;
    const cssW = wrap ? wrap.clientWidth : fallbackW;
    const cssH = wrap ? wrap.clientHeight : fallbackH;
    return { cssW, cssH };
  }

  function isChartFolded(card) {
  return card?.classList.contains("folded");
}

function toggleChartFold(card) {
  if (!card) return;
  card.classList.toggle("folded");

  // When unfolding, redraw if a redraw hook exists
  if (!isChartFolded(card)) {
    const redraw = card.__redrawCandles;
    if (typeof redraw === "function") redraw();
  }
}

function wireAllChartFoldToggles(rootEl = document) {
  rootEl.querySelectorAll(".chartCard .chartTop").forEach(top => {
    if (top.__wired) return;
    top.__wired = true;

    top.addEventListener("click", (e) => {
      // ignore clicks on buttons/links inside the header
      if (e.target && e.target.closest && e.target.closest("button, a")) return;

      const card = top.closest(".chartCard");
      toggleChartFold(card);
    });

    // optional: keyboard accessibility (Enter/Space)
    top.setAttribute("tabindex", "0");
    top.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        const card = top.closest(".chartCard");
        toggleChartFold(card);
      }
    });
  });
}
 

// -----------------------------
// Overlays: Last price line + Moving averages
// -----------------------------

function computeSMA(values, window) {
  const w = Math.max(1, Math.floor(Number(window) || 1));
  const out = new Array(values.length).fill(null);
  let sum = 0;
  let q = [];
  for (let i = 0; i < values.length; i++) {
    const v = Number(values[i]);
    if (!Number.isFinite(v)) { out[i] = null; continue; }

    q.push(v);
    sum += v;

    if (q.length > w) sum -= q.shift();

    if (q.length === w) out[i] = sum / w;
    else out[i] = null;
  }
  return out;
}

function drawPolyline(ctx, points, strokeStyle, lineWidth = 1.6) {
  if (!points || points.length < 2) return;
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  let started = false;
  for (const p of points) {
    if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) {
      started = false;
      continue;
    }
    if (!started) {
      ctx.moveTo(p.x, p.y);
      started = true;
    } else {
      ctx.lineTo(p.x, p.y);
    }
  }
  ctx.stroke();
  ctx.restore();
}

function drawHLine(ctx, y, padL, padR, cssW, label, strokeStyle) {
  if (!Number.isFinite(y)) return;
  ctx.save();
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 4]);
  ctx.beginPath();
  ctx.moveTo(padL, y);
  ctx.lineTo(cssW - padR, y);
  ctx.stroke();
  ctx.setLineDash([]);

  // label
  ctx.font = "12px system-ui";
  ctx.fillStyle = strokeStyle;
  const text = String(label || "");
  const tw = ctx.measureText(text).width;
  const x = cssW - padR - tw - 6;
  const yy = y - 6; // slightly above the line
  ctx.fillText(text, x, yy);

  ctx.restore();
}

function drawTopLegend(ctx, items, padL, padT, cssW, padR) {
  // items: [{ label, color }]
  const x0 = padL + 6;
  const y0 = padT + 14;
  const maxX = cssW - padR - 6;

  ctx.save();
  ctx.font = "12px system-ui";
  ctx.textBaseline = "alphabetic";

  let x = x0;
  const gap = 20;     // gap between legend items (increased for better spacing)
  const dotR = 6;     // dot radius (larger for better visibility)

  for (const it of (items || [])) {
    const label = String(it?.label || "");
    const color = String(it?.color || "rgba(232,238,252,.85)");

    // measure width: dot + space + label
    const tw = ctx.measureText(label).width;
    const need = (dotR * 2) + 10 + tw + gap;

    // if legend row is too long, stop (or you can wrap to 2nd row)
    if (x + need > maxX) break;

    // dot
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x + dotR, y0, dotR, 0, Math.PI * 2);
    ctx.fill();

    // label
    ctx.fillStyle = "rgba(232,238,252,.85)";
    ctx.fillText(label, x + (dotR * 2) + 10, y0);

    x += need;
  }

  ctx.restore();
}

  // -----------------------------
  // Mode / route selection
  // -----------------------------
  const MODE_KEY = "xtrader_trading_ui_mode_v1"; // "execute" | "signal"
  let mode = localStorage.getItem(MODE_KEY) || "execute";

  function applyModeUI() {
    const isExec = mode === "execute";
    $("modeExecute").classList.toggle("active", isExec);
    $("modeSignal").classList.toggle("active", !isExec);
    $("routeLabel").textContent = isExec ? "/execute/{symbol}" : "/signal/{symbol}";
    $("btnOnce").textContent = isExec ? "Execute (Call Once)" : "Signal (Call Once)";
    $("btnStart").textContent = isExec ? "Start Auto Execute" : "Start Auto Signal";
  }

  function setMode(next) {
    mode = (next === "signal") ? "signal" : "execute";
    localStorage.setItem(MODE_KEY, mode);
    applyModeUI();
  }

  // -----------------------------
  // Persistence (form)
  // -----------------------------
  const LS_KEY = "xtrader_trading_ui_v4_strategy_mode"; // bump key to avoid old incompatible market fields
  function saveForm() {
    const data = {
      symbol: $("symbol").value,
      cash: $("cash").value,
      pos: $("pos").value,
      avgCost: $("avgCost").value,
      upl: $("upl").value,
      nowTs: $("nowTs").value,
      freqSec: $("freqSec").value,

      tzName: $("tzName").value,
      strategyMode: $("strategyMode").value,

      lotSize: $("lotSize").value,
      maxOrderShares: $("maxOrderShares").value,
      feesBps: $("feesBps").value,
      slipBps: $("slipBps").value,

      marketMinPeriod: $("marketMinPeriod").value,
      marketMinLookback: $("marketMinLookback").value,
      marketIncludeBars: $("marketIncludeBars").value,
      marketIncludeOrderbook: $("marketIncludeOrderbook").value,
      marketExtra: $("marketExtra").value,

      mode,
    };
    localStorage.setItem(LS_KEY, JSON.stringify(data));
  }

  function loadForm() {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return;
    try {
      const d = JSON.parse(raw);
      $("symbol").value = d.symbol ?? "";
      $("cash").value = d.cash ?? "";
      $("pos").value = d.pos ?? "";
      $("avgCost").value = d.avgCost ?? "";
      $("upl").value = d.upl ?? "";
      $("nowTs").value = d.nowTs ?? "";
      $("freqSec").value = d.freqSec ?? "";

      $("tzName").value = d.tzName ?? "";
      $("strategyMode").value = d.strategyMode ?? "normal";

      $("lotSize").value = d.lotSize ?? "";
      $("maxOrderShares").value = d.maxOrderShares ?? "";
      $("feesBps").value = d.feesBps ?? "";
      $("slipBps").value = d.slipBps ?? "";

      $("marketMinPeriod").value = d.marketMinPeriod ?? "";
      $("marketMinLookback").value = d.marketMinLookback ?? "";
      $("marketIncludeBars").value = d.marketIncludeBars ?? "true";
      $("marketIncludeOrderbook").value = d.marketIncludeOrderbook ?? "false";
      $("marketExtra").value = d.marketExtra ?? "";

      if (d.mode) mode = d.mode;
    } catch {}
  }

  // -----------------------------
  // Payload builder (MATCHES BACKEND MODELS)
  // TradingContextIn:
  // { account_state, now_ts?, options? }
  //
  // ExecutionOptionsIn:
  // { timezone_name, lot_size, max_order_shares, fees_bps_est, slippage_bps_est, strategy_mode, market }
  //
  // MarketOptionsIn:
  // { min_period, min_lookback_minutes, include_orderbook, include_bars, extra }
  // -----------------------------
  function parseJsonObjectOrNull(s) {
    const raw = String(s ?? "").trim();
    if (!raw) return null;
    try {
      const obj = JSON.parse(raw);
      if (obj && typeof obj === "object" && !Array.isArray(obj)) return obj;
      return null;
    } catch {
      return null;
    }
  }

  function buildPayload() {
    const account_state = {
      cash_cny: safeNumber($("cash").value, 0),
      position_shares: safeNumber($("pos").value, 0),
      avg_cost_cny: safeNumber($("avgCost").value, 0),
      unrealized_pnl_cny: safeNumber($("upl").value, 0),
    };

    const now_ts_user = normalizeNowTs($("nowTs").value);

    // options (always send a consistent shape; backend has defaults but we keep it explicit)
    const opt = {};

    const tzName = String($("tzName").value || "").trim();
    if (tzName) opt.timezone_name = tzName;

    const strategyMode = String($("strategyMode").value || "").trim();
    if (strategyMode) opt.strategy_mode = strategyMode;

    const lotSize = safeNumber($("lotSize").value, null);
    const maxOrderShares = safeNumber($("maxOrderShares").value, null);
    const feesBps = safeNumber($("feesBps").value, null);
    const slipBps = safeNumber($("slipBps").value, null);

    if (lotSize !== null) opt.lot_size = Math.max(1, Math.floor(lotSize));
    if (maxOrderShares !== null) opt.max_order_shares = Math.max(0, Math.floor(maxOrderShares));
    if (feesBps !== null) opt.fees_bps_est = Math.max(0, Math.floor(feesBps));
    if (slipBps !== null) opt.slippage_bps_est = Math.max(0, Math.floor(slipBps));

    // market options matching MarketOptionsIn
    const market = {};
    const minPeriod = String($("marketMinPeriod").value || "").trim();
    const minLookback = safeNumber($("marketMinLookback").value, null);
    const includeBars = safeBoolFromSelect($("marketIncludeBars").value, null);
    const includeOrderbook = safeBoolFromSelect($("marketIncludeOrderbook").value, null);

    if (minPeriod) market.min_period = minPeriod;
    if (minLookback !== null) market.min_lookback_minutes = Math.max(1, Math.floor(minLookback));
    if (includeBars !== null) market.include_bars = includeBars;
    if (includeOrderbook !== null) market.include_orderbook = includeOrderbook;

    const extraObj = parseJsonObjectOrNull($("marketExtra").value);
    if (extraObj) market.extra = extraObj;

    opt.market = market;

    const payload = { account_state };
    if (now_ts_user) payload.now_ts = now_ts_user;
    payload.options = opt;

    return payload;
  }

  // Parse "YYYY-MM-DD HH:MM:SS" as Asia/Shanghai time into epoch ms
  function parseShanghaiTsMs(s) {
    if (!s) return null;
    const m = String(s).trim().match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
    if (!m) {
      const d = new Date(String(s));
      return isNaN(d.getTime()) ? null : d.getTime();
    }
    const yyyy = Number(m[1]);
    const MM = Number(m[2]);
    const dd = Number(m[3]);
    const hh = Number(m[4]);
    const mi = Number(m[5]);
    const ss = Number(m[6]);
    // Shanghai is UTC+8
    return Date.UTC(yyyy, MM - 1, dd, hh - 8, mi, ss);
  }

  // -----------------------------
  // Intraday summary (DB-driven, FIFO on DB records)
  // -----------------------------
  function isDbAcceptedPaperTrade(r) {
    if (!r) return false;
    const action = normalizeAction(r.action);
    if (action !== "BUY" && action !== "SELL") return false;

    const ok = (r.ok === true) || (String(r.ok) === "1") || (Number(r.ok) === 1);
    if (!ok) return false;

    const lots = Number(r.suggested_lots);
    if (!Number.isFinite(lots) || lots <= 0) return false;

    return true;
  }

  function sortDbTradesChronologically(records) {
    const arr = records.slice();
    arr.sort((a, b) => {
      const ta = parseShanghaiTsMs(a.decision_ts) ?? 0;
      const tb = parseShanghaiTsMs(b.decision_ts) ?? 0;
      return ta - tb;
    });
    return arr;
  }

  function getLastPriceHintFromDb(records) {
    return null;
  }

  function computeIntradaySummaryFromDb(symbol, dbRecords) {
    const sym = String(symbol || "").trim();
    const rows = Array.isArray(dbRecords) ? dbRecords : [];

    const trades = sortDbTradesChronologically(
      rows.filter(r => String(r.symbol || sym || "") === sym).filter(isDbAcceptedPaperTrade)
    );

    const queue = [];

    let acceptedCount = 0;
    let buyLotsTotal = 0;
    let sellLotsTotal = 0;

    let buySharesTotal = 0;
    let sellSharesTotal = 0;

    let realized = 0;
    let realizedFee = 0;

    let winSegments = 0;
    let loseSegments = 0;
    let flatSegments = 0;

    let missingBuyPxLots = 0;
    let missingSellPxLots = 0;

    for (const t of trades) {
      acceptedCount += 1;

      const action = normalizeAction(t.action);
      const lots = Math.max(0, Math.floor(Number(t.suggested_lots)));
      if (!lots) continue;

      const lotSize = Number.isFinite(Number(t.lot_size)) ? Math.max(1, Math.floor(Number(t.lot_size))) : 100;

      const shares = Number.isFinite(Number(t.suggested_shares))
        ? Math.max(0, Math.floor(Number(t.suggested_shares)))
        : (lots * lotSize);

      const px = Number.isFinite(Number(t.executed_price_cny)) ? Number(t.executed_price_cny) : null;

      const fee = Number.isFinite(Number(t.fees_cny)) ? Number(t.fees_cny) : 0;
      realizedFee += fee;

      if (action === "BUY") {
        buyLotsTotal += lots;
        buySharesTotal += shares;
        if (px === null) missingBuyPxLots += lots;

        queue.push({ lots, price: px, lotSize, sharesPerLot: lotSize });
      } else if (action === "SELL") {
        sellLotsTotal += lots;
        sellSharesTotal += shares;
        if (px === null) missingSellPxLots += lots;

        let remainingLots = lots;
        const sellPx = px;

        while (remainingLots > 0 && queue.length > 0) {
          const head = queue[0];
          const matchLots = Math.min(remainingLots, head.lots);

          const buyPx = head.price;
          const sharesPerLot = head.sharesPerLot || 100;
          const matchShares = matchLots * sharesPerLot;

          if (buyPx !== null && sellPx !== null) {
            const seg = (sellPx - buyPx) * matchShares;
            realized += seg;
            if (seg > 0) winSegments += 1;
            else if (seg < 0) loseSegments += 1;
            else flatSegments += 1;
          }

          head.lots -= matchLots;
          remainingLots -= matchLots;

          if (head.lots <= 0) queue.shift();
        }
      }
    }

    let openLots = 0;
    let openShares = 0;
    let openCost = 0;
    let openLotsMissingPx = 0;

    for (const q of queue) {
      if (!q || q.lots <= 0) continue;
      openLots += q.lots;
      const sharesPerLot = q.sharesPerLot || 100;
      const sh = q.lots * sharesPerLot;
      openShares += sh;

      if (q.price !== null) openCost += (q.price * sh);
      else openLotsMissingPx += q.lots;
    }

    const lastPrice = getLastPriceHintFromDb(rows);
    let unrealized = null;
    let total = null;
    if (Number.isFinite(Number(lastPrice))) {
      const lp = Number(lastPrice);
      const mktValue = lp * openShares;
      unrealized = mktValue - openCost;
      total = realized + unrealized;
    }

    const netLots = buyLotsTotal - sellLotsTotal;
    const netSharesExact = buySharesTotal - sellSharesTotal;

    return {
      acceptedCount,
      buyLotsTotal,
      sellLotsTotal,
      buySharesTotal,
      sellSharesTotal,
      netLots,
      netSharesExact,

      openLots,
      openShares,

      realized,
      realizedFee,
      unrealized,
      total,

      winSegments,
      loseSegments,
      flatSegments,

      missingBuyPxLots,
      missingSellPxLots,
      openLotsMissingPx,
      lastPrice
    };
  }

  function renderSummaryFromDb(symbol, dbRecords) {
    const sym = String(symbol || "").trim();
    const bar = $("summaryBar");
    const note = $("summaryNote");
    if (!bar || !note) return;

    if (!sym) {
      note.textContent = "Type a symbol to compute intraday summary (DB-driven).";
      return;
    }

    const s = computeIntradaySummaryFromDb(sym, dbRecords);

    const unreal = (s.unrealized === null) ? "—" : formatCny(s.unrealized);
    const total = (s.total === null) ? "—" : formatCny(s.total);

    const pxNote = (s.missingBuyPxLots || s.missingSellPxLots || s.openLotsMissingPx)
      ? `<span class="pill bad">missing prices</span>
         <span class="muted">buy-missing=${escapeHtml(String(s.missingBuyPxLots))} lots • sell-missing=${escapeHtml(String(s.missingSellPxLots))} lots • open-missing=${escapeHtml(String(s.openLotsMissingPx))} lots</span>`
      : `<span class="pill ok">prices ok</span>`;

    note.innerHTML = `
      Symbol <span class="pill info"><code>${escapeHtml(sym)}</code></span>
      • Updated at <span class="pill info">${escapeHtml(shanghaiNowYmdHms())}</span>
      • Source: <span class="pill info">DB /trade_history</span>
      • ${pxNote}
    `;

    bar.innerHTML = `
      <div class="kv">
        <div class="k">Accepted paper trades (DB)</div>
        <div class="v">${escapeHtml(String(s.acceptedCount))}</div>
        <div class="s muted">win=${escapeHtml(String(s.winSegments))} • lose=${escapeHtml(String(s.loseSegments))} • flat=${escapeHtml(String(s.flatSegments))}</div>
      </div>
      <div class="kv">
        <div class="k">Net lots / shares (exact)</div>
        <div class="v">${escapeHtml(String(s.netLots))} lots</div>
        <div class="s muted">${escapeHtml(String(s.netSharesExact))} shares (from suggested_shares or lots×lot_size)</div>
      </div>
      <div class="kv">
        <div class="k">Realized PnL (CNY)</div>
        <div class="v">${escapeHtml(formatCny(s.realized))}</div>
        <div class="s muted">FIFO on executed_price_cny • fees sum=${escapeHtml(formatCny(s.realizedFee))}</div>
      </div>
      <div class="kv">
        <div class="k">Unrealized / Total (CNY)</div>
        <div class="v">${escapeHtml(unreal)} <span class="muted">/</span> ${escapeHtml(total)}</div>
        <div class="s muted">open=${escapeHtml(String(s.openLots))} lots • ${escapeHtml(String(s.openShares))} shares • last price: ${s.lastPrice === null ? "missing" : escapeHtml(String(Number(s.lastPrice).toFixed(2)))}</div>
      </div>
    `;
  }

  // -----------------------------
  // Candlestick chart + markers code
  // Source switched to: GET /api/stock/bars
  // -----------------------------
  function parseBarTsMs(ts) {
    if (!ts) return null;
    const s = String(ts);
    const d1 = new Date(s);
    if (!isNaN(d1.getTime())) return d1.getTime();
    const d2 = new Date(s.replace(" ", "T"));
    if (!isNaN(d2.getTime())) return d2.getTime();
    return null;
  }

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  // -----------------------------
// Zoom engine (drag-to-zoom on X range)
// -----------------------------

function invertXToTs(bars, x, geom) {
  // bars: sorted [{t,...}]
  if (!bars || bars.length < 2) return null;
  const { padL, padR, cssW } = geom || {};
  const W = Math.max(1, (cssW ?? 0) - (padL ?? 0) - (padR ?? 0));
  const n = bars.length;
  const xStep = W / Math.max(1, n - 1);

  const xx = clamp(x, padL, padL + W);
  const iFloat = (xx - padL) / xStep;
  const i0 = Math.max(0, Math.min(n - 1, Math.floor(iFloat)));
  const i1 = Math.max(0, Math.min(n - 1, Math.ceil(iFloat)));
  if (i0 === i1) return bars[i0].t;

  const frac = iFloat - i0;
  const t0 = bars[i0].t;
  const t1 = bars[i1].t;
  if (!Number.isFinite(t0) || !Number.isFinite(t1)) return null;
  return t0 + (t1 - t0) * frac;
}

function setZoomHint(card, text) {
  const el = card?.querySelector(".chartHint .hintZoom");
  if (el) el.textContent = text || "";
}

function wireZoomForChart(card, canvas, getFullBars, getMarkers, redrawWithView) {
  // card.__zoomState = { enabled, view:{tMin,tMax}|null }
  if (!card || !canvas) return;

  card.__zoomState = card.__zoomState || { enabled: false, view: null };

  const btnZoom = card.querySelector('button[data-act="zoom"]');
  const btnReset = card.querySelector('button[data-act="reset"]');
  const zoomBox = card.querySelector(".zoomBox");

  const setZoomEnabledUI = (on) => {
    if (btnZoom) btnZoom.classList.toggle("active", !!on);
    setZoomHint(card, on ? "Drag on chart to zoom. Double-click to reset." : "");
  };

  const applyView = (view) => {
    card.__zoomState.view = view || null;
    redrawWithView(card.__zoomState.view);
  };

  // Buttons
  if (btnZoom && !btnZoom.__wiredZoom) {
    btnZoom.__wiredZoom = true;
    btnZoom.addEventListener("click", (e) => {
      e.stopPropagation(); // don’t fold/unfold
      card.__zoomState.enabled = !card.__zoomState.enabled;
      setZoomEnabledUI(card.__zoomState.enabled);
    });
  }
  if (btnReset && !btnReset.__wiredReset) {
    btnReset.__wiredReset = true;
    btnReset.addEventListener("click", (e) => {
      e.stopPropagation();
      card.__zoomState.enabled = false;
      setZoomEnabledUI(false);
      applyView(null);
    });
  }

  // dblclick reset
  if (!canvas.__wiredDblReset) {
    canvas.__wiredDblReset = true;
    canvas.addEventListener("dblclick", (e) => {
      card.__zoomState.enabled = false;
      setZoomEnabledUI(false);
      applyView(null);
    });
  }

  // Drag selection
  if (canvas.__wiredZoomDrag) return;
  canvas.__wiredZoomDrag = true;

  let dragging = false;
  let startX = 0, startY = 0;

  const getLocalXY = (evt) => {
    const rect = canvas.getBoundingClientRect();
    const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
    const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top, rect };
  };

  const showBox = (x0, y0, x1, y1) => {
    if (!zoomBox) return;
    const left = Math.min(x0, x1);
    const top = Math.min(y0, y1);
    const w = Math.abs(x1 - x0);
    const h = Math.abs(y1 - y0);
    zoomBox.style.display = "block";
    zoomBox.style.left = left + "px";
    zoomBox.style.top = top + "px";
    zoomBox.style.width = w + "px";
    zoomBox.style.height = h + "px";
  };

  const hideBox = () => {
    if (!zoomBox) return;
    zoomBox.style.display = "none";
  };

  const onDown = (evt) => {
    if (!card.__zoomState.enabled) return;
    // prevent scroll on touch drag
    if (evt.cancelable) evt.preventDefault();

    const { x, y } = getLocalXY(evt);
    dragging = true;
    startX = x; startY = y;
    showBox(startX, startY, startX, startY);
  };

  const onMove = (evt) => {
    if (!dragging) return;
    if (evt.cancelable) evt.preventDefault();

    const { x, y } = getLocalXY(evt);
    showBox(startX, startY, x, y);
  };

  const onUp = (evt) => {
    if (!dragging) return;
    if (evt.cancelable) evt.preventDefault();

    dragging = false;

    const { x } = getLocalXY(evt);
    hideBox();

    // Require some minimum drag distance
    if (Math.abs(x - startX) < 10) return;

    // Use the last drawn geometry & bars (set by drawCandlesOnCanvas)
    const geom = canvas.__chartGeom;
    const barsShown = canvas.__barsShown;

    if (!geom || !barsShown || barsShown.length < 2) return;

    const tA = invertXToTs(barsShown, startX, geom);
    const tB = invertXToTs(barsShown, x, geom);
    if (!Number.isFinite(tA) || !Number.isFinite(tB)) return;

    const tMin = Math.min(tA, tB);
    const tMax = Math.max(tA, tB);

    // If user zooms too small, ignore
    if (tMax - tMin < 60_000) return; // < 1 min

    applyView({ tMin, tMax });

    // Auto turn off zoom mode after applying
    card.__zoomState.enabled = false;
    setZoomEnabledUI(false);
  };

  canvas.addEventListener("mousedown", onDown);
  window.addEventListener("mousemove", onMove);
  window.addEventListener("mouseup", onUp);

  canvas.addEventListener("touchstart", onDown, { passive: false });
  window.addEventListener("touchmove", onMove, { passive: false });
  window.addEventListener("touchend", onUp, { passive: false });

  // initial UI
  setZoomEnabledUI(card.__zoomState.enabled);
}


function renderCandleChartShell(symbol) {
  return `
    <div class="chartCard folded" data-chart="candles">
      <div class="chartTop" title="Click to fold/unfold">
        <div class="title"><span class="chev">▾</span>Market Snapshot Candles</div>
        <div class="meta">
          <span class="pill info"><code>${escapeHtml(symbol || "—")}</code></span>
          <span class="muted">source=<code>/api/stock/bars</code> • <span class="candleMeta">(loading…)</span></span>
          <span class="muted">•</span>
          <span class="chartTools">
            <button class="toolBtn" type="button" data-act="zoom">Zoom</button>
            <button class="toolBtn" type="button" data-act="reset">Reset</button>
          </span>
        </div>
      </div>
      <div class="chartWrap">
        <canvas class="candle"></canvas>
        <div class="zoomBox"></div>
        <div class="markerTip"></div>
      </div>
      <div class="chartHint">
        Loading bars from <code>/api/stock/bars</code>…
        <span class="hintZoom muted"></span>
      </div>
    </div>
  `;
}

function buildExecuteMarkerFromResponse(root, tsShanghai) {
  const action = pick(root, ["action"]) || pick(root?.details?.signal, ["action"]);
  const a = normalizeAction(action);
  if (a !== "BUY" && a !== "SELL") return [];

  const lots = extractLotsFromResponse(root);
  const price = extractCallPriceFromResponse(root);

  const t = parseShanghaiTsMs(tsShanghai);
  if (t == null) return [];

  // Here we ensure that only one marker per action (BUY/SELL) for a given timestamp
  return [{
    t,
    action: a,
    price: (Number.isFinite(Number(price)) ? Number(price) : null),
    lots: (Number.isFinite(Number(lots)) ? Math.floor(Number(lots)) : null),
    tsShanghai: tsShanghai || null
  }];
}
 
    // -----------------------------
  // Marker + candle helpers (drop-in)
  // Requires: clamp(), escapeHtml(), toShTsYmdHmsFromMs() (you already have),
  // and your CSS classes: .markerTip, .dot.buy/.dot.sell
  // -----------------------------

  // Global marker hit-test state (init)
  window.__markerHit = window.__markerHit || {
    canvas: null,
    markersPx: [],
    tipEl: null,
    _bound: false,
    _lastIdx: -1,
  };

// Map a timestamp to an X coordinate within the plot area.
// - ohlc: [{t,o,h,l,c}, ...] with .t in epoch ms sorted ascending
// - padL: left padding in CSS px
// - W: plot width in CSS px
// Uses linear interpolation between neighboring bars.
function xOfTs(bars, t, padL, W) {
  if (!bars || bars.length === 0 || t === null || t === undefined) return null;

  const n = bars.length;
  if (n === 1) return padL + W / 2;

  const t0 = bars[0].t;
  const tN = bars[n - 1].t;
  if (!Number.isFinite(t0) || !Number.isFinite(tN) || tN === t0) return null;

  // If outside range, clamp to edges
  if (t <= t0) return padL;
  if (t >= tN) return padL + W;

  // Binary search for rightmost index with ohlc[i].t <= t
  let lo = 0, hi = n - 1;
  while (lo + 1 < hi) {
    const mid = (lo + hi) >> 1;
    if (bars[mid].t <= t) lo = mid;
    else hi = mid;
  }

  const tA = bars[lo].t;
  const tB = bars[hi].t;
  const frac = (tB === tA) ? 0 : (t - tA) / (tB - tA);

  const xStep = W / Math.max(1, n - 1);
  const xA = padL + lo * xStep;
  const xB = padL + hi * xStep;
  return xA + (xB - xA) * frac;
}

  // Apply simple vertical collision avoidance so markers don't overlap too much.
  // - markersPx: [{x,y,r,action,price,lots,tsShanghai,t}, ...]
  // Returns a NEW array with adjusted y values.
  function applyMarkerCollisionOffsets(markersPx, minDy = 14) {
    const arr = (Array.isArray(markersPx) ? markersPx : []).map(m => ({ ...m }));
    if (arr.length <= 1) return arr;

    // Sort by x then y so clusters get adjusted deterministically
    arr.sort((a, b) => (a.x - b.x) || (a.y - b.y));

    const xBucket = Math.max(10, minDy * 1.2);

    // For each marker, if it conflicts with previous close-by markers, shift it up/down alternately.
    for (let i = 0; i < arr.length; i++) {
      const m = arr[i];
      if (!Number.isFinite(m.x) || !Number.isFinite(m.y)) continue;

      // consider only prior markers in nearby x-range
      const neighbors = [];
      for (let j = i - 1; j >= 0; j--) {
        const p = arr[j];
        if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
        if (m.x - p.x > xBucket) break;
        neighbors.push(p);
      }

      if (!neighbors.length) continue;

      // iterative push until no conflicts
      let tries = 0;
      while (tries < 20) {
        let conflict = false;
        for (const p of neighbors) {
          if (Math.abs(m.x - p.x) <= xBucket && Math.abs(m.y - p.y) < minDy) {
            conflict = true;
            break;
          }
        }
        if (!conflict) break;

        // alternate shifts: up, down, up, down with growing magnitude
        const k = Math.floor(tries / 2) + 1;
        const dir = (tries % 2 === 0) ? -1 : +1;
        m.y += dir * (minDy * 0.85) * k;
        tries += 1;
      }
    }

    return arr;
  }

  // Draw a BUY/SELL marker on canvas
  // - ctx is scaled to CSS pixels (as in ensureCanvasHiDpi) 
function drawActionMarker(ctx, x, y, action, opts = {}) {
  const a = String(action || "").toUpperCase();
  const r = Number.isFinite(Number(opts.radius)) ? Number(opts.radius) : 7;

  // outer ring (circle)
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.fillStyle = (a === "SELL") ? "rgba(255,107,107,.95)" : "rgba(110,168,254,.95)"; // red for sell, blue for buy

  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // inner letter (B for Buy, S for Sell)
  ctx.fillStyle = "rgba(0,0,0,.55)"; // dark text color
  ctx.font = "bold 12px Arial"; // Bold font, 12px size
  ctx.textAlign = "center"; // Center the text horizontally
  ctx.textBaseline = "middle"; // Center the text vertically

  const text = a === "SELL" ? "S" : "B"; // "S" for sell, "B" for buy
  ctx.fillText(text, x, y); // Draw the letter in the center of the circle

  ctx.restore();
}

  // Tooltip + hover binding for markers on a given canvas
  function bindMarkerHover(canvas) {
    if (!canvas) return;

    // Avoid rebinding multiple times on the same canvas
    if (window.__markerHit._bound && window.__markerHit.canvas === canvas) return;

    window.__markerHit.canvas = canvas;
    window.__markerHit._bound = true;
    window.__markerHit._lastIdx = -1;

    const tipEl = window.__markerHit.tipEl || canvas.parentElement?.querySelector(".markerTip") || null;
    window.__markerHit.tipEl = tipEl;

    const getMousePos = (evt) => {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      return { x, y, rect };
    };

    const hideTip = () => {
      if (tipEl) tipEl.style.display = "none";
      window.__markerHit._lastIdx = -1;
    };

    const showTip = (mp, clientX, clientY, rect) => {
      if (!tipEl) return;

      const a = String(mp.action || "").toUpperCase();
      const dotCls = (a === "SELL") ? "dot sell" : "dot buy";
      const priceStr = Number.isFinite(Number(mp.price)) ? Number(mp.price).toFixed(3) : "—";
      const lotsStr = (mp.lots !== null && mp.lots !== undefined) ? String(mp.lots) : "—";

      // Prefer Shanghai time label if provided; else derive from epoch
      const tsLabel =
        (mp.tsShanghai && String(mp.tsShanghai).trim())
          ? String(mp.tsShanghai).trim()
          : (Number.isFinite(Number(mp.t)) ? toShTsYmdHmsFromMs(Number(mp.t)) : "—");

      tipEl.innerHTML = `
        <div class="a"><span class="${dotCls}"></span>${escapeHtml(a)} @ ${escapeHtml(priceStr)}</div>
        <div class="sub">lots=${escapeHtml(lotsStr)} • ${escapeHtml(tsLabel)}</div>
      `;

      // Position tip near cursor but keep within chart wrap bounds
      const pad = 8;
      tipEl.style.display = "block";

      // initial position
      let left = clientX - rect.left;
      let top = clientY - rect.top;

      // measure
      const tw = tipEl.offsetWidth;
      const th = tipEl.offsetHeight;

      // clamp inside container
      left = clamp(left, pad + tw / 2, rect.width - pad - tw / 2);
      top = clamp(top, pad + th, rect.height - pad);

      tipEl.style.left = left + "px";
      tipEl.style.top = top + "px";
    };

    const hitTest = (mx, my) => {
      const ms = window.__markerHit.markersPx || [];
      if (!ms.length) return { idx: -1, mp: null };

      let best = -1;
      let bestD2 = Infinity;

      for (let i = 0; i < ms.length; i++) {
        const p = ms[i];
        const r = Number.isFinite(Number(p.r)) ? Number(p.r) : 8;
        const dx = mx - p.x;
        const dy = my - p.y;
        const d2 = dx * dx + dy * dy;
        if (d2 <= r * r && d2 < bestD2) {
          bestD2 = d2;
          best = i;
        }
      }

      return { idx: best, mp: best >= 0 ? ms[best] : null };
    };

    const onMove = (evt) => {
      const { x, y, rect } = getMousePos(evt);
      const { idx, mp } = hitTest(x, y);

      if (idx < 0 || !mp) {
        hideTip();
        canvas.style.cursor = "default";
        return;
      }

      canvas.style.cursor = "pointer";

      // Only update DOM if changed (reduces jitter)
      if (window.__markerHit._lastIdx !== idx) {
        window.__markerHit._lastIdx = idx;
      }
      showTip(mp, evt.clientX, evt.clientY, rect);
    };

    const onLeave = () => {
      canvas.style.cursor = "default";
      hideTip();
    };

    canvas.addEventListener("mousemove", onMove);
    canvas.addEventListener("mouseleave", onLeave);
    canvas.addEventListener("touchstart", (evt) => {
      if (!evt.touches || !evt.touches[0]) return;
      const t = evt.touches[0];
      const fakeEvt = { clientX: t.clientX, clientY: t.clientY };
      const rect = canvas.getBoundingClientRect();
      const x = t.clientX - rect.left;
      const y = t.clientY - rect.top;
      const { idx, mp } = hitTest(x, y);
      if (idx >= 0 && mp) {
        canvas.style.cursor = "pointer";
        showTip(mp, t.clientX, t.clientY, rect);
      } else {
        hideTip();
      }
    }, { passive: true });
    canvas.addEventListener("touchend", onLeave, { passive: true });
  }

function drawCandlesOnCanvas(canvas, ohlc, markers = [], view = null) {
  const wrap = canvas.parentElement;
  const cssW = wrap ? wrap.clientWidth : 900;
  const cssH = wrap ? wrap.clientHeight : 260;

  const ctx = ensureCanvasHiDpi(canvas, cssW, cssH);

  // Clear full backing store regardless of dpr transform
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  // Apply zoom window (X-range) if provided
  let bars = Array.isArray(ohlc) ? ohlc : [];
  if (view && Number.isFinite(view.tMin) && Number.isFinite(view.tMax)) {
    const a = view.tMin, b = view.tMax;
    bars = bars.filter(x => Number.isFinite(x.t) && x.t >= a && x.t <= b);
  }

  // Store what is currently shown for zoom inversion mapping
  canvas.__barsShown = bars;
 
  if (!bars || bars.length < 2) {
    ctx.fillStyle = "rgba(232,238,252,.7)";
    ctx.font = "12px system-ui";
    ctx.fillText("No bars", 10, 18);
    return;
  }

  const padL = 40, padR = 60, padT = 10, padB = 22;
  const W = Math.max(1, cssW - padL - padR);
  const H = Math.max(1, cssH - padT - padB);

  canvas.__chartGeom = { cssW, cssH, padL, padR, padT, padB };

  // price scale
  let minP = Infinity, maxP = -Infinity;
  for (const b of bars) {
    minP = Math.min(minP, b.l);
    maxP = Math.max(maxP, b.h);
  }
  if (!(maxP > minP)) { maxP = minP + 1e-6; }

  // Add a little padding so MA/last line labels have breathing room
  const padPct = 0.02;
  const range = (maxP - minP);
  minP -= range * padPct;
  maxP += range * padPct;

  const yOf = (p) => padT + (maxP - p) * (H / (maxP - minP));
  const xStep = W / Math.max(1, bars.length - 1);
  const xOfIdx = (i) => padL + i * xStep;

  // axes
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padL, padT);
  ctx.lineTo(padL, padT + H);
  ctx.lineTo(padL + W, padT + H);
  ctx.stroke();

  // Y-axis (right-side) ticks + labels
  const tickCount = 5;
  ctx.save();
  ctx.fillStyle = "rgba(232,238,252,.85)";
  ctx.font = "11px system-ui";
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for (let i = 0; i <= tickCount; i++) {
    const frac = i / tickCount;
    const y = padT + frac * H;
    const price = maxP - frac * (maxP - minP);
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.beginPath();
    ctx.moveTo(padL, y);
    ctx.lineTo(padL + W, y);
    ctx.stroke();
    ctx.fillText(price.toFixed(3), cssW - 6, y);
  }
  ctx.restore();

  // candles
  for (let i = 0; i < bars.length; i++) {
    const b = bars[i];
    const x = xOfIdx(i);

    const yO = yOf(b.o);
    const yC = yOf(b.c);
    const yH = yOf(b.h);
    const yL = yOf(b.l);

    const up = b.c >= b.o;

    // wick
    ctx.strokeStyle = "rgba(255,255,255,.55)";
    ctx.beginPath();
    ctx.moveTo(x, yH);
    ctx.lineTo(x, yL);
    ctx.stroke();

    // body
    const bw = Math.max(1, Math.min(12, xStep * 0.9));
    const top = Math.min(yO, yC);
    const bot = Math.max(yO, yC);
    const bh = Math.max(1.5, bot - top);

    ctx.fillStyle = up ? "rgba(64,192,128,.65)" : "rgba(255,107,107,.55)";
    ctx.fillRect(x - bw / 2, top, bw, bh);

    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.strokeRect(x - bw / 2, top, bw, bh);
  }

  // -----------------------------
  // Draw Datetime on X-axis
  // -----------------------------
  const timeFormat = new Intl.DateTimeFormat("en-GB", {
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit", second: "2-digit"
  });

  const labelPadding = 10; // space between labels

  // Draw date labels at the bottom of each candle
  let lastX = -Infinity;  // Keep track of last label's x position to avoid overlap
  for (let i = 0; i < bars.length; i++) {
    const bar = bars[i];
    const x = xOfIdx(i);
    const dateStr = timeFormat.format(new Date(bar.t)); // Format the datetime

    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    const textWidth = ctx.measureText(dateStr).width;
    const padding = 5;

    // If the distance between current label and last label is too small, skip drawing this label
    if (x - lastX > textWidth + labelPadding) {
      // Draw the datetime label at the bottom of each candle
      ctx.fillText(dateStr, x, H + padT + padding);
      lastX = x;  // Update the position of the last label
    }
  }

  // -----------------------------
  // Moving Averages (MA)
  // -----------------------------
  const closes = bars.map(b => b.c);

  // choose your MA windows here
  const maWindows = [5, 10, 20];
  const maStyles = {
    5:  "rgba(110,168,254,.95)",
    10: "rgba(255,203,92,.95)",
    20: "rgba(190,140,255,.95)",
  };

  const legendItems = [];
  // draw MA lines
  for (const w of maWindows) {
    const sma = computeSMA(closes, w);
    const pts = sma.map((v, i) => {
      if (!Number.isFinite(v)) return null;
      return { x: xOfIdx(i), y: yOf(v) };
    });

    const color = maStyles[w] || "rgba(255,255,255,.8)";
    drawPolyline(ctx, pts, color, 1.8);

    // legend label uses the most recent MA value (if available)
    const lastV = sma[sma.length - 1];
    const label = Number.isFinite(lastV)
      ? `MA${w}: ${Number(lastV).toFixed(3)}`
      : `MA${w}: —`;

    legendItems.push({ label, color });
  }

  drawTopLegend(ctx, legendItems, padL, padT, cssW, padR);

  // last price horizontal line (latest close)
  const lastClose = closes[closes.length - 1];
  if (Number.isFinite(Number(lastClose))) {
    const yLast = yOf(Number(lastClose));
    drawHLine(
      ctx,
      yLast,
      padL,
      padR,
      cssW,
      `Last ${Number(lastClose).toFixed(3)}`,
      "rgba(232,238,252,.85)"
    );
  }

  // -----------------------------
  // Markers
  // -----------------------------
  const markersPx = [];
  for (const m of markers) {
    const x = xOfTs(bars, m.t, padL, W);
    if (x == null) continue;

    const price = Number.isFinite(Number(m.price)) ? Number(m.price) : bars[bars.length - 1].c;
    const y = yOf(price);

    markersPx.push({
      x, y, r: 8,
      action: m.action,
      price,
      lots: m.lots ?? null,
      tsShanghai: m.tsShanghai ?? null,
      t: m.t
    });
  }

  const placed = applyMarkerCollisionOffsets(markersPx, 14);
  for (const mp of placed) {
    drawActionMarker(ctx, mp.x, mp.y, mp.action, { radius: 7 });
  }

  // bind hover hit-test
  window.__markerHit.canvas = canvas;
  window.__markerHit.markersPx = placed;
  window.__markerHit.tipEl = canvas.parentElement?.querySelector(".markerTip") || null;
  bindMarkerHover(canvas);

  bindCandleHover(canvas);
}

function bindCandleHover(canvas) {
  if (!canvas) return;
  if (canvas.__candleHoverBound) return;
  canvas.__candleHoverBound = true;

  const tipEl = canvas.parentElement?.querySelector(".candleTip") || null;
  if (!tipEl) return;

  const getMousePos = (evt) => {
    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;
    return { x, y, rect };
  };

  const hideTip = () => {
    tipEl.style.display = "none";
  };

  const showTip = (bar, clientX, clientY, rect) => {
    const timeStr = new Intl.DateTimeFormat("en-GB", {
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit"
    }).format(new Date(bar.t));

    tipEl.innerHTML = `
      <div class="t">${escapeHtml(timeStr)}</div>
      <div class="sub">O=${escapeHtml(bar.o.toFixed(3))} H=${escapeHtml(bar.h.toFixed(3))} L=${escapeHtml(bar.l.toFixed(3))} C=${escapeHtml(bar.c.toFixed(3))}</div>
    `;

    const pad = 8;
    tipEl.style.display = "block";
    let left = clientX - rect.left;
    let top = clientY - rect.top;
    const tw = tipEl.offsetWidth;
    const th = tipEl.offsetHeight;
    left = clamp(left, pad + tw / 2, rect.width - pad - tw / 2);
    top = clamp(top, pad + th, rect.height - pad);
    tipEl.style.left = left + "px";
    tipEl.style.top = top + "px";
  };

  const onMove = (evt) => {
    const bars = canvas.__barsShown;
    const geom = canvas.__chartGeom;
    if (!bars || bars.length < 1 || !geom) return;

    const { x, rect } = getMousePos(evt);
    const { padL, padR, cssW } = geom;
    const W = Math.max(1, cssW - padL - padR);
    const n = bars.length;
    const xStep = W / Math.max(1, n - 1);
    const xx = clamp(x, padL, padL + W);
    const iFloat = (xx - padL) / xStep;
    const idx = Math.max(0, Math.min(n - 1, Math.round(iFloat)));
    const bar = bars[idx];
    if (!bar) return;
    showTip(bar, evt.clientX, evt.clientY, rect);
  };

  const onLeave = () => hideTip();

  canvas.addEventListener("mousemove", onMove);
  canvas.addEventListener("mouseleave", onLeave);
}

  // NOTE: candle drawing + marker building from DB left as in your original version.
  // If you want, I can paste the remaining candle functions verbatim too, but it makes this file huge.
  // For now, your existing candle + history marker logic will continue to work unchanged.

  // -----------------------------
  // Pretty response rendering (unchanged except: we show strategy_mode used)
  // -----------------------------
  function renderResponse(data, meta) {
    const root = data ?? {};
    const symbol = pick(root, ["symbol"]) || meta?.symbol || "—";
    const isExecute = mode === "execute";

    const action =
      pick(root, ["action"]) ||
      pick(root?.details?.signal, ["action"]);

    const ok = pick(root, ["ok"]);
    const msg = pick(root, ["message", "detail"]) || (isExecute ? "" : "(signal only)");
    const ts = pick(root, ["ts"]) || meta?.startedShanghai;

    const shares = pick(root, ["shares"]);
    const lots = pick(root, ["lots"]) ?? pick(root, ["suggested_lots"]) ?? pick(root?.details?.signal, ["suggested_lots"]);
    const paper = pick(root, ["paper"]);

    const rawJson = pretty(root);

    const top = `
      <div class="respTop">
        <div class="respTitle">
          <strong>${isExecute ? "Execute" : "Signal"}</strong>
          <span class="pill info"><code>${escapeHtml(symbol)}</code></span>
          ${actionPill(action)}
          ${isExecute && ok === true ? `<span class="pill ok">OK</span>` : isExecute && ok === false ? `<span class="pill bad">FAIL</span>` : ``}
          ${isExecute && paper !== undefined ? `<span class="pill info">paper=${escapeHtml(String(paper))}</span>` : ``}
        </div>
        <button class="copyBtn" id="copyRawBtn">Copy Raw JSON</button>
      </div>
    `;

    const strategyMode = String($("strategyMode").value || "normal");

    const kvs = `
      <div class="kvs">
        <div class="kv">
          <div class="k">Timestamp</div>
          <div class="v">${escapeHtml(String(ts || "—"))}</div>
          <div class="s muted">UI uses Asia/Shanghai; API may return its own ts.</div>
        </div>
        <div class="kv">
          <div class="k">Strategy Mode (sent)</div>
          <div class="v">${escapeHtml(strategyMode)}</div>
          <div class="s muted">Must match backend StrategyMode enum.</div>
        </div>
        <div class="kv">
          <div class="k">Message</div>
          <div class="v">${escapeHtml(String(msg || "—"))}</div>
          <div class="s muted">${isExecute ? "Backend may include risk blocks / broker messages." : "Signal endpoint returns a signal object."}</div>
        </div>
        <div class="kv">
          <div class="k">${isExecute ? "Lots (executed/requested)" : "suggested_lots"}</div>
          <div class="v">${escapeHtml(lots === undefined ? "—" : String(lots))}</div>
          <div class="s muted">Lots unit = 手. HOLD should be 0.</div>
        </div>
        <div class="kv">
          <div class="k">${isExecute ? "Shares" : "confidence"}</div>
          <div class="v">${
            isExecute
              ? escapeHtml(shares === undefined ? "—" : String(shares))
              : escapeHtml(pick(root, ["confidence"]) === undefined ? "—" : String(pick(root, ["confidence"])))
          }</div>
          <div class="s muted">${isExecute ? "Executed/requested shares from response." : "0..1 calibrated confidence."}</div>
        </div>
      </div>
    `;
   
    const detailsSignal = pick(root?.details, ["signal"]) || (isExecute ? null : root);
    const detailsSnapshot = pick(root?.details, ["snapshot"]);

    const extra = `
      <details ${isExecute ? "" : "open"}>
        <summary>${isExecute ? "LLM Signal (details.signal)" : "Signal JSON"}</summary>
        <pre>${escapeHtml(detailsSignal ? pretty(detailsSignal) : "(empty)")}</pre>
      </details>
      <details>
        <summary>Market Snapshot (details.snapshot)</summary>
        <pre>${escapeHtml(detailsSnapshot ? pretty(detailsSnapshot) : "(empty) — only returned by /execute")}</pre>
      </details>
      <details open>
        <summary>Raw JSON</summary>
        <pre>${escapeHtml(rawJson)}</pre>
      </details>
    `;


    $("resp").innerHTML = top + kvs + extra;
    wireAllChartFoldToggles($("resp"));

    const btn = $("copyRawBtn");
    if (btn) {
      btn.onclick = async () => {
        const okc = await copyToClipboard(rawJson);
        btn.textContent = okc ? "Copied!" : "Copy failed";
        setTimeout(() => (btn.textContent = "Copy Raw JSON"), 1200);
      };
    }

    if (isExecute) {
      wireAllChartFoldToggles($("resp")); 
    }

  }

  function renderError(errText, raw, meta) {
    const html = `
      <div class="respTop">
        <div class="respTitle">
          <strong>Request Failed</strong>
          <span class="pill info"><code>${escapeHtml(meta?.symbol || "—")}</code></span>
          <span class="pill bad">ERROR</span>
        </div>
        <button class="copyBtn" id="copyErrBtn">Copy</button>
      </div>
      <div class="kv">
        <div class="k">Error</div>
        <div class="s">${escapeHtml(errText)}</div>
      </div>
      <details open>
        <summary>Raw</summary>
        <pre>${escapeHtml(raw || "")}</pre>
      </details>
    `;
    $("resp").innerHTML = html;

    const btn = $("copyErrBtn");
    if (btn) {
      btn.onclick = async () => {
        const ok = await copyToClipboard(`${errText}\n\n${raw || ""}`);
        btn.textContent = ok ? "Copied!" : "Copy failed";
        setTimeout(() => (btn.textContent = "Copy"), 1200);
      };
    }
  }

  // -----------------------------
  // History
  // -----------------------------
  const HISTORY_LIMIT = 30;
  let historyRecords = [];
  const HISTORY_SNAPSHOT_REFRESH_MS = 60_000;
  let historySnapshotTimer = null;

  function shanghaiNowParts() {
    const parts = new Intl.DateTimeFormat("sv-SE", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      weekday: "short",
      hour12: false
    }).formatToParts(new Date());

    const get = (type) => parts.find(p => p.type === type)?.value ?? "";
    return {
      year: Number(get("year")),
      month: Number(get("month")),
      day: Number(get("day")),
      hour: Number(get("hour")),
      minute: Number(get("minute")),
      second: Number(get("second")),
      weekday: get("weekday") || ""
    };
  }

  function isShanghaiTradingTimeNow() {
    const p = shanghaiNowParts();
    const wd = String(p.weekday || "").toLowerCase();
    const isWeekday = !["sat", "sun"].includes(wd);
    if (!isWeekday) return false;
    const mins = (p.hour * 60) + p.minute;
    const amOpen = 9 * 60 + 30;
    const amClose = 11 * 60 + 30;
    const pmOpen = 13 * 60;
    const pmClose = 15 * 60;
    const inMorning = mins >= amOpen && mins < amClose;
    const inAfternoon = mins >= pmOpen && mins <= pmClose;
    return inMorning || inAfternoon;
  }

  function shanghaiLastTradingYmd() {
    const p = shanghaiNowParts();
    const nowMs = Date.UTC(p.year, p.month - 1, p.day, p.hour - 8, p.minute, p.second);
    let d = new Date(nowMs);
    let offsetDays = 0;

    const isBeforeOpen = (p.hour * 60 + p.minute) < (9 * 60 + 30);
    if (isBeforeOpen) offsetDays = 1;

    const wd = String(p.weekday || "").toLowerCase();
    if (wd === "sat") offsetDays = Math.max(offsetDays, 1);
    if (wd === "sun") offsetDays = Math.max(offsetDays, 2);

    // If it is Monday before open, go back to Friday
    if (wd === "mon" && isBeforeOpen) offsetDays = Math.max(offsetDays, 3);

    if (offsetDays > 0) {
      d = new Date(d.getTime() - offsetDays * 24 * 60 * 60 * 1000);
    }
    return toShTsYmdHmsFromMs(d.getTime()).slice(0, 10);
  }

  function shanghaiSafeBarsRangeFromRecords(records) {
    if (records && records.length) {
      return shanghaiRangeFromRecords(records, 1);
    }
    if (isShanghaiTradingTimeNow()) {
      return shanghaiRecentDaysRangeHms(1);
    }
    const ymd = shanghaiLastTradingYmd();
    return { start: `${ymd} 00:00:00`, end: `${ymd} 23:59:59` };
  }

  function statusPillFromDbStatus(status) {
    const s = String(status || "").toUpperCase();
    if (s.includes("FAIL") || s.includes("ERROR")) return `<span class="pill bad">${escapeHtml(s || "FAIL")}</span>`;
    if (s.includes("OK") || s.includes("EXEC") || s.includes("DONE") || s.includes("FILLED")) return `<span class="pill ok">${escapeHtml(s || "OK")}</span>`;
    return `<span class="pill info">${escapeHtml(s || "—")}</span>`;
  }


  async function renderHistoryFromBackend(records) {
    const container = $("history");
    const rows = Array.isArray(records) ? records : [];
    const sorted = rows.slice().sort((a, b) => {
      const ta = parseShanghaiTsMs(a?.decision_ts) ?? 0;
      const tb = parseShanghaiTsMs(b?.decision_ts) ?? 0;
      return tb - ta;
    });
    historyRecords = sorted.slice(0, HISTORY_LIMIT);

    if (!historyRecords.length) {
      container.textContent = "(empty)";
      renderSummaryFromDb(normalizeSymbol($("symbol").value), historyRecords);
      await renderIndividualChartsFromHistory(normalizeSymbol($("symbol").value), historyRecords);
      return;
    }

    container.innerHTML = historyRecords.map((r, idx) => {
      const sym = `<code>${escapeHtml(String(r.symbol || $("symbol").value || "—").trim() || "—")}</code>`;
      const ts = r.decision_ts || "—";
      const action = r.action ? actionPill(r.action) : "";
      const lots = (r.suggested_lots !== undefined && r.suggested_lots !== null)
        ? `<span class="pill info">lots=${escapeHtml(String(r.suggested_lots))}</span>` : "";
      const shares = (r.suggested_shares !== undefined && r.suggested_shares !== null)
        ? `<span class="pill info">shares=${escapeHtml(String(r.suggested_shares))}</span>` : "";
      const conf = (r.confidence !== undefined && r.confidence !== null)
        ? `<span class="pill info">conf=${escapeHtml(String(r.confidence))}</span>` : "";
      const st = statusPillFromDbStatus(r.status);
      const msg = r.message ? escapeHtml(String(r.message)) : "";

      return `
        <div class="histItem">
          <div class="histTop">
            <div class="histMeta">
              ${st}
              <span class="pill info">db</span>
              ${sym}
              ${action}
              ${lots}
              ${shares}
              ${conf}
              <span class="muted">•</span>
              <span class="muted">${escapeHtml(String(ts))}</span>
            </div>
            <button class="copyBtn" data-idx="${idx}">Copy</button>
          </div>
          <div class="histSmall">${msg}</div>
        </div>
      `;
    }).join("");

    container.querySelectorAll("button.copyBtn[data-idx]").forEach(btn => {
      btn.onclick = async () => {
        const idx = Number(btn.getAttribute("data-idx"));
        const item = historyRecords[idx];
        const payload = pretty(item);
        const ok = await copyToClipboard(payload);
        btn.textContent = ok ? "Copied!" : "Copy failed";
        setTimeout(() => (btn.textContent = "Copy"), 1200);
      };
    });

    // summary
    renderSummaryFromDb(normalizeSymbol($("symbol").value), historyRecords);

    // IMPORTANT: await charts so "refresh" truly includes snapshot charts
    await renderIndividualChartsFromHistory(normalizeSymbol($("symbol").value), historyRecords);
  }

  function makeMarkerFromDbRecord(r) {
  const action = normalizeAction(r.action);
  if (action !== "BUY" && action !== "SELL") return null;

  const t = parseShanghaiTsMs(r.decision_ts);
  if (t == null) return null;

  const lots = Number.isFinite(Number(r.suggested_lots)) ? Math.floor(Number(r.suggested_lots)) : null;

  // prefer executed_price_cny; fallback to null (marker will use last close)
  const price = Number.isFinite(Number(r.executed_price_cny)) ? Number(r.executed_price_cny) : null;

  return {
    t,
    action,
    price,
    lots,
    tsShanghai: r.decision_ts || null
  };
}

// simple concurrency limiter (avoid 30 parallel requests)
async function mapLimit(items, limit, fn) {
  const out = [];
  let i = 0;
  const workers = new Array(Math.max(1, limit)).fill(0).map(async () => {
    while (i < items.length) {
      const idx = i++;
      out[idx] = await (async () => {
        try {
          return await fn(items[idx], idx);
        } catch (e) {
          // Don’t break the whole batch
          const card = document.getElementById(`chartCard_${idx}`);
          const hint = card?.querySelector(".chartHint");
          if (hint) hint.innerHTML = `<span class="pill bad">load failed</span> <span class="muted">${escapeHtml(String(e))}</span>`;
          return null;
        }
      })();

    }
  });
  await Promise.all(workers);
  return out;
}

function isBuySellRecordForSymbol(r, sym) {
  const action = normalizeAction(r?.action);
  if (action !== "BUY" && action !== "SELL") return false;
  const rs = String(r?.symbol || "").trim();
  return !sym || !rs || rs === sym;
}

function shanghaiRangeFromRecords(records, fallbackDays = 1) {
  const rows = Array.isArray(records) ? records : [];
  let minMs = Infinity;
  let maxMs = -Infinity;

  for (const r of rows) {
    const t = parseShanghaiTsMs(r?.decision_ts);
    if (!Number.isFinite(t)) continue;
    if (t < minMs) minMs = t;
    if (t > maxMs) maxMs = t;
  }

  if (!Number.isFinite(minMs) || !Number.isFinite(maxMs)) {
    return shanghaiRecentDaysRangeHms(fallbackDays);
  }

  const minYmd = toShTsYmdHmsFromMs(minMs).slice(0, 10);
  const maxYmd = toShTsYmdHmsFromMs(maxMs).slice(0, 10);
  return {
    start: `${minYmd} 00:00:00`,
    end: `${maxYmd} 23:59:59`,
  };
}

function stopHistorySnapshotAutoRefresh() {
  if (historySnapshotTimer) {
    clearInterval(historySnapshotTimer);
    historySnapshotTimer = null;
  }
}

async function renderIndividualChartsFromHistory(symbol, records) {
  const list = $("chartsList");
  if (!list) return;

  const sym = normalizeSymbol(symbol);
  const rows = Array.isArray(records) ? records : [];
  if (!sym) {
    list.innerHTML = "";
    stopHistorySnapshotAutoRefresh();
    wireAllChartFoldToggles(list);
    return;
  }

  // Clear existing chart card before appending a new one
  list.innerHTML = "";

  // Build one consolidated chart with ALL BUY/SELL markers (or none if empty history)
  const candidates = rows.filter(r => isBuySellRecordForSymbol(r, sym));

  const latestTs = candidates
    .map(r => parseShanghaiTsMs(r.decision_ts))
    .filter(t => Number.isFinite(t))
    .sort((a, b) => b - a)[0];
  const latestLabel = Number.isFinite(latestTs) ? toShTsYmdHmsFromMs(latestTs) : shanghaiNowYmdHms();

  list.innerHTML = `
    <div class="chartCard snapshot folded" id="chartCard_0">
      <div class="chartTop">
        <div class="title"><span class="chev">▾</span><span class="badge">Snapshot</span>History Candles @ ${escapeHtml(String(latestLabel))}</div>
        <div class="meta">
          <span class="pill info"><code>${escapeHtml(sym)}</code></span>
          <span class="pill info">markers=${escapeHtml(String(candidates.length))}</span>
          <span class="muted">freq=${escapeHtml(String($("marketMinPeriod").value || "1"))}</span>
          <span class="muted">•</span>
          <span class="chartTools">
            <button class="toolBtn" type="button" data-act="zoom">Zoom</button>
            <button class="toolBtn" type="button" data-act="reset">Reset</button>
          </span>
        </div>
      </div>
      <div class="chartWrap">
        <canvas id="candle_0" class="candle"></canvas>
        <div class="zoomBox"></div>
        <div class="markerTip"></div>
        <div class="candleTip"></div>
      </div>
      <div class="chartHint muted">
        Loading bars from <code>/api/stock/bars</code>…
        <span class="hintZoom muted"></span>
      </div>
    </div>
  `;

  const freq = String($("marketMinPeriod").value || "1").trim() || "1";
  const { start, end } = shanghaiSafeBarsRangeFromRecords(candidates);

  const payload = await fetchBarsFromApi(sym, start, end, freq, null); // no limit
  let currentOhlc = extractBarsFromBarsApiPayload(payload);

  let currentMarkers = candidates
    .map(makeMarkerFromDbRecord)
    .filter(Boolean)
    .sort((a, b) => (a.t ?? 0) - (b.t ?? 0));

  const canvas = $("candle_0");
  const card = document.getElementById("chartCard_0");
  if (!canvas || !card) return;

  const redraw = (view = null) => drawCandlesOnCanvas(canvas, currentOhlc, currentMarkers, view);

  // keep current zoom view on redraws
  card.__redrawCandles = () => redraw(card.__zoomState?.view || null);

  // wire zoom (works even when folded; active after unfold draw)
  wireZoomForChart(
    card,
    canvas,
    () => currentOhlc,
    () => currentMarkers,
    (view) => redraw(view)
  );

  // If user already unfolded quickly, render now
  if (!isChartFolded(card)) {
    redraw(null);
  }

  // Auto-refresh bars every minute (and include new markers on next history refresh)
  stopHistorySnapshotAutoRefresh();
  historySnapshotTimer = setInterval(async () => {
    if (!card.isConnected) {
      stopHistorySnapshotAutoRefresh();
      return;
    }
    if (!isShanghaiTradingTimeNow()) return;
    try {
      const nextCandidates = historyRecords.filter(r => isBuySellRecordForSymbol(r, sym));
      const range = shanghaiSafeBarsRangeFromRecords(nextCandidates);
      const nextPayload = await fetchBarsFromApi(sym, range.start, range.end, freq, null);
      const nextOhlc = extractBarsFromBarsApiPayload(nextPayload);
      const nextMarkers = nextCandidates
        .map(makeMarkerFromDbRecord)
        .filter(Boolean)
        .sort((a, b) => (a.t ?? 0) - (b.t ?? 0));
      currentOhlc = nextOhlc;
      currentMarkers = nextMarkers;
      card.__redrawCandles = () => redraw(card.__zoomState?.view || null);
      card.__redrawCandles();
    } catch {}
  }, HISTORY_SNAPSHOT_REFRESH_MS);

  wireAllChartFoldToggles(list);
}


  async function fetchTradeHistoryFromBackend(symbol, limit = HISTORY_LIMIT) {
    const sym = normalizeSymbol(symbol);
    if (!sym) return { symbol: "", count: 0, records: [] };

    const nowTsUser = normalizeNowTs($("nowTs").value);
    const nowTs = nowTsUser || shanghaiNowYmdHms();

    const url =
      `/trade_history/${encodeURIComponent(sym)}` +
      `?now_ts=${encodeURIComponent(nowTs)}` +
      `&limit=${encodeURIComponent(String(limit))}`;

    const resp = await fetch(url, { method: "GET" });
    const rawText = await resp.text();
    let data;
    try { data = JSON.parse(rawText); } catch { data = { raw: rawText }; }

    if (!resp.ok) {
      renderError(`History API failed: HTTP ${resp.status} ${resp.statusText}`, pretty(data), { symbol: sym });
      return { symbol: sym, count: 0, records: [] };
    }
    return data;
  }


  async function refreshHistory(symbol) {
    const sym = normalizeSymbol(symbol);
    if (!sym) {
      await renderHistoryFromBackend([]);
      return;
    }
    try {
      const data = await fetchTradeHistoryFromBackend(sym, HISTORY_LIMIT);
      await renderHistoryFromBackend(data?.records || []);
    } catch (e) {
      renderError(`History fetch error: ${e}`, "", { symbol: sym });
      await renderHistoryFromBackend([]);
    }
  }

  // -----------------------------
  // API call (no overlap auto)
  // -----------------------------
  let running = false;
  let timer = null;

  function currentRouteForSymbol(symbol) {
    return (mode === "signal")
      ? `/signal/${encodeURIComponent(symbol)}`
      : `/execute/${encodeURIComponent(symbol)}`;
  }

  async function callOnce() {
    if (running) return;
    running = true;

    saveForm();
    const symbol = normalizeSymbol($("symbol").value);

    if (!symbol) {
      renderError("symbol is required (6 digits).", "", { symbol: "" });
      setRunState("idle", "bad");
      running = false;
      return;
    }

    const sm = String($("strategyMode").value || "").trim();
    if (!["mild","normal","aggressive"].includes(sm)) {
      renderError(`Invalid strategy_mode: ${sm}`, "", { symbol });
      running = false;
      return;
    }

    const payload = buildPayload();
    const url = currentRouteForSymbol(symbol);
    const startedShanghai = shanghaiNowYmdHms();

    $("lastCall").textContent = startedShanghai;
    setRunState(timer ? "running" : "calling...");

    try {
      const resp = await fetch(url, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload),
      });

      const rawText = await resp.text();
      let data;
      try { data = JSON.parse(rawText); } catch { data = { raw: rawText }; }

      if (!resp.ok) {
        const msg = `HTTP ${resp.status} ${resp.statusText}`;
        setRunState(timer ? "running" : "idle", "bad");
        setStatus(startedShanghai, msg);

        renderError(msg, pretty(data), { symbol, startedShanghai });
        await refreshHistory(symbol);

        running = false;
        return;
      }

      setRunState(timer ? "running" : "idle", "ok");
      setStatus(startedShanghai, "ok");

      renderResponse(data, { symbol, startedShanghai });
      await refreshHistory(pick(data, ["symbol"]) || symbol);

    } catch (e) {
      const msg = `FETCH_ERROR: ${e}`;
      setRunState(timer ? "running" : "idle", "bad");
      setStatus(startedShanghai, msg);
      renderError(msg, "", { symbol, startedShanghai });
    } finally {
      running = false;
    }
  }

  function startAuto() {
    saveForm();

    const freq = safeNumber($("freqSec").value, null);
    if (!freq || freq < 1) {
      renderError("frequency must be >= 1 second.", "", { symbol: normalizeSymbol($("symbol").value) });
      setRunState("idle", "bad");
      return;
    }

    if (timer) clearInterval(timer);

    $("btnStart").disabled = true;
    $("btnStop").disabled = false;
    setRunState("running", "info");

    callOnce();
    timer = setInterval(callOnce, Math.floor(freq * 1000));
  }

  function stopAuto() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
    $("btnStart").disabled = false;
    $("btnStop").disabled = true;
    setRunState("idle", "info");
  }

  function clearOutput() {
    $("resp").innerHTML = `<div class="muted">(cleared)</div>`;
    $("history").textContent = "(empty)";
    historyRecords = [];
    setStatus(null, null);

    const sym = normalizeSymbol($("symbol").value);
    renderSummaryFromDb(sym, historyRecords);
  }

  // -----------------------------
  // Wiring
  // -----------------------------
  loadForm();
  applyModeUI();

  $("modeExecute").addEventListener("click", () => setMode("execute"));
  $("modeSignal").addEventListener("click", () => setMode("signal"));

  [
    "symbol","cash","pos","avgCost","upl","nowTs","freqSec",
    "tzName","strategyMode",
    "lotSize","maxOrderShares","feesBps","slipBps",
    "marketMinPeriod","marketMinLookback","marketIncludeBars","marketIncludeOrderbook","marketExtra"
  ].forEach(id => {
    $(id).addEventListener("input", saveForm);
    $(id).addEventListener("change", saveForm);
  });

  $("btnOnce").addEventListener("click", callOnce);
  $("btnStart").addEventListener("click", startAuto);
  $("btnStop").addEventListener("click", stopAuto);
  $("btnClear").addEventListener("click", clearOutput);

  // Defaults
  if (!$("freqSec").value) $("freqSec").value = "30";
  if (!$("cash").value) $("cash").value = "100000";
  if (!$("pos").value) $("pos").value = "0";
  if (!$("avgCost").value) $("avgCost").value = "0";
  if (!$("upl").value) $("upl").value = "0";

  if (!$("tzName").value) $("tzName").value = "Asia/Shanghai";
  if (!$("strategyMode").value) $("strategyMode").value = "normal";

  if (!$("lotSize").value) $("lotSize").value = "100";
  if (!$("maxOrderShares").value) $("maxOrderShares").value = "10000";
  if (!$("feesBps").value) $("feesBps").value = "5";
  if (!$("slipBps").value) $("slipBps").value = "5";

  if (!$("marketMinPeriod").value) $("marketMinPeriod").value = "1";
  if (!$("marketMinLookback").value) $("marketMinLookback").value = "120";
  if (!$("marketIncludeBars").value) $("marketIncludeBars").value = "true";
  if (!$("marketIncludeOrderbook").value) $("marketIncludeOrderbook").value = "false";

  setStatus(null, null);
  setRunState("idle", "info");

  refreshHistory(normalizeSymbol($("symbol").value));

  $("symbol").addEventListener("change", () => {
    const sym = normalizeSymbol($("symbol").value);
    refreshHistory(sym);
  });
</script>
</body>
</html>
